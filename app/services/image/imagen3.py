import asyncio
import os
from typing import Optional
from datetime import datetime
from io import BytesIO

try:
    from google import genai as imagen_genai
    from google.genai import types
    from PIL import Image
except ImportError:
    imagen_genai = None
    types = None
    Image = None

from app.core.config import settings
from .base import BaseImageService, ImageResult, ImageProvider

class Imagen3Service(BaseImageService):
    """Imagen 3 API„Çí‰ΩøÁî®„Åó„ÅüÁîªÂÉèÁîüÊàê„Çµ„Éº„Éì„Çπ"""
    
    def __init__(self):
        super().__init__()
        self.provider = ImageProvider.IMAGEN3
        self.client = None
        self._initialize_client()
    
    def _initialize_client(self):
        """Imagen 3 API„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÇíÂàùÊúüÂåñ"""
        try:
            if not imagen_genai or not types or not Image:
                print("‚ùå google-genai or PIL package not installed. Install with: pip install google-genai pillow")
                return
                
            if settings.GEMINI_API_KEY and settings.IMAGE_GENERATION_ENABLED:
                self.client = imagen_genai.Client(api_key=settings.GEMINI_API_KEY)
                print("üîß Imagen 3 Service initialized successfully")
            else:
                print("‚ö†Ô∏è GEMINI_API_KEY not set or IMAGE_GENERATION_ENABLED is False")
                
        except Exception as e:
            print(f"‚ùå Failed to initialize Imagen 3 Service: {e}")
            self.client = None
    
    def is_available(self) -> bool:
        """„Çµ„Éº„Éì„Çπ„ÅåÂà©Áî®ÂèØËÉΩ„Åã„ÉÅ„Çß„ÉÉ„ÇØ"""
        return (self.client is not None and 
                bool(settings.GEMINI_API_KEY) and 
                settings.IMAGE_GENERATION_ENABLED and
                imagen_genai is not None and
                types is not None and
                Image is not None)
    
    async def generate_single_image(
        self, 
        japanese_name: str, 
        english_name: str, 
        description: str, 
        category: str
    ) -> dict:
        """Âçò‰∏Ä„ÅÆ„É°„Éã„É•„Éº„Ç¢„Ç§„ÉÜ„É†„ÅÆÁîªÂÉè„ÇíÁîüÊàê"""
        try:
            # ÁîªÂÉèÁîüÊàêÁî®„ÅÆ„Éó„É≠„É≥„Éó„Éà‰ΩúÊàê
            prompt = self.create_image_prompt(japanese_name, english_name, description, category)
            
            if not self.validate_prompt_content(prompt):
                raise ValueError("Invalid prompt content")
            
            # Imagen 3„ÅßÁîªÂÉèÁîüÊàê
            response = self.client.models.generate_images(
                model=settings.IMAGEN_MODEL,
                prompt=prompt,
                config=types.GenerateImagesConfig(
                    number_of_images=settings.IMAGEN_NUMBER_OF_IMAGES,
                    aspect_ratio=settings.IMAGEN_ASPECT_RATIO
                )
            )
            
            if response.generated_images:
                # ÁîªÂÉè„Çí‰øùÂ≠ò
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = self.create_safe_filename(english_name, timestamp)
                image_path = f"{settings.UPLOAD_DIR}/{filename}"
                
                # „Éá„Ç£„É¨„ÇØ„Éà„É™„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØ‰ΩúÊàê
                os.makedirs(settings.UPLOAD_DIR, exist_ok=True)
                
                # ÁîªÂÉè„Çí‰øùÂ≠ò
                generated_image = response.generated_images[0]
                image = Image.open(BytesIO(generated_image.image.image_bytes))
                image.save(image_path)
                
                # ÁµêÊûú„ÇíËøî„Åô
                return {
                    "japanese_name": japanese_name,
                    "english_name": english_name,
                    "image_url": f"/{settings.UPLOAD_DIR}/{filename}",
                    "image_path": image_path,
                    "prompt_used": prompt,
                    "generation_success": True
                }
            else:
                return {
                    "japanese_name": japanese_name,
                    "english_name": english_name,
                    "image_url": None,
                    "error": "No image generated by Imagen 3",
                    "generation_success": False
                }
                
        except Exception as e:
            return {
                "japanese_name": japanese_name,
                "english_name": english_name,
                "image_url": None,
                "error": str(e),
                "generation_success": False
            }
    
    async def generate_images(
        self, 
        final_menu: dict, 
        session_id: Optional[str] = None
    ) -> ImageResult:
        """
        „É°„Éã„É•„Éº„Ç¢„Ç§„ÉÜ„É†„ÅÆÁîªÂÉè„ÇíImagen 3„ÅßÁîüÊàê
        
        Args:
            final_menu: Ë©≥Á¥∞Ë™¨Êòé‰ªò„Åç„É°„Éã„É•„Éº„Éá„Éº„Çø
            session_id: „Çª„ÉÉ„Ç∑„Éß„É≥IDÔºàÈÄ≤Ë°åÁä∂Ê≥ÅÈÄöÁü•Áî®Ôºâ
            
        Returns:
            ImageResult: ÁîªÂÉèÁîüÊàêÁµêÊûú
        """
        print("üé® Starting image generation with Imagen 3...")
        
        # „Çµ„Éº„Éì„ÇπÂà©Áî®ÂèØËÉΩÊÄß„ÉÅ„Çß„ÉÉ„ÇØ
        if not self.is_available():
            return ImageResult(
                success=True,  # ÁîªÂÉèÁîüÊàê„ÅØ„Ç™„Éó„Ç∑„Éß„Éä„É´„Å™„ÅÆ„ÅßÊàêÂäü„Å®„Åô„Çã
                image_method="imagen3",
                metadata={
                    "skipped_reason": "Imagen 3 not available",
                    "error_type": "service_unavailable",
                    "suggestions": [
                        "Set GEMINI_API_KEY environment variable",
                        "Install required packages: google-genai, pillow",
                        "Enable IMAGE_GENERATION_ENABLED in settings",
                        "Check Gemini API access permissions"
                    ]
                }
            )
        
        # ÂÖ•Âäõ„Éá„Éº„Çø„ÅÆÂ¶•ÂΩìÊÄß„ÉÅ„Çß„ÉÉ„ÇØ
        if not self.validate_menu_data(final_menu):
            return ImageResult(
                success=False,
                image_method="imagen3",
                error="Invalid menu data",
                metadata={
                    "error_type": "invalid_input",
                    "suggestions": [
                        "Provide valid menu data with descriptions",
                        "Ensure at least one category has menu items",
                        "Check menu data structure format"
                    ]
                }
            )
        
        try:
            images_generated = {}
            total_items = sum(len(items) for items in final_menu.values())
            processed_items = 0
            successful_images = 0
            
            print(f"üñºÔ∏è Total items to generate images for: {total_items}")
            
            # „Ç´„ÉÜ„Ç¥„É™„Åî„Å®„Å´ÁîªÂÉèÁîüÊàê
            for category, items in final_menu.items():
                if not items:
                    images_generated[category] = []
                    continue
                    
                print(f"üé® Generating images for category: {category} ({len(items)} items)")
                
                # ÈÄ≤ÊçóÈÄÅ‰ø°Ôºà„Ç´„ÉÜ„Ç¥„É™ÈñãÂßãÔºâ
                if session_id:
                    from app.main import send_progress
                    await send_progress(
                        session_id, 5, "active", 
                        f"üé® {category}„ÅÆÁîªÂÉè„ÇíÁîüÊàê‰∏≠...",
                        {"processing_category": category, "total_categories": len(final_menu)}
                    )
                
                category_images = []
                
                # „Ç´„ÉÜ„Ç¥„É™ÂÜÖ„ÅÆÂêÑ„Ç¢„Ç§„ÉÜ„É†„Å´ÂØæ„Åó„Å¶ÁîªÂÉèÁîüÊàê
                for i, item in enumerate(items):
                    if not self.validate_menu_item(item):
                        print(f"  ‚ö†Ô∏è Skipping invalid menu item: {item}")
                        processed_items += 1
                        continue
                    
                    japanese_name = item.get("japanese_name", "N/A")
                    english_name = item.get("english_name", "N/A")
                    description = item.get("description", "")
                    
                    print(f"  üñºÔ∏è Generating image {i+1}/{len(items)}: {english_name}")
                    
                    # ÈÄ≤ÊçóÈÄÅ‰ø°ÔºàÂÄãÂà•„Ç¢„Ç§„ÉÜ„É†Ôºâ
                    if session_id:
                        await send_progress(
                            session_id, 5, "active", 
                            f"üé® {category}: {english_name}„ÅÆÁîªÂÉè„ÇíÁîüÊàê‰∏≠...",
                            {"current_item": english_name, "item_progress": f"{i+1}/{len(items)}"}
                        )
                    
                    # Âçò‰∏ÄÁîªÂÉèÁîüÊàê
                    image_result = await self.generate_single_image(
                        japanese_name, english_name, description, category
                    )
                    
                    category_images.append(image_result)
                    processed_items += 1
                    
                    if image_result.get("generation_success"):
                        successful_images += 1
                        print(f"    ‚úÖ Image generated successfully: {image_result.get('image_url')}")
                    else:
                        print(f"    ‚ùå Failed to generate image for {english_name}: {image_result.get('error', 'Unknown error')}")
                    
                    # ÈÄ≤ÊçóÊõ¥Êñ∞
                    if session_id:
                        progress_percent = int((processed_items / total_items) * 100)
                        await send_progress(
                            session_id, 5, "active", 
                            f"üé® {category}: {english_name}„ÅÆÁîªÂÉèÁîüÊàêÂÆå‰∫Ü",
                            {
                                "progress_percent": progress_percent,
                                "completed_item": english_name,
                                "images_generated": len([img for img in category_images if img.get("generation_success")]),
                                "images_failed": len([img for img in category_images if not img.get("generation_success")])
                            }
                        )
                    
                    # „É¨„Éº„ÉàÂà∂ÈôêÂØæÁ≠ñ
                    await asyncio.sleep(settings.IMAGE_RATE_LIMIT_SLEEP)
                
                images_generated[category] = category_images
                
                # „Ç´„ÉÜ„Ç¥„É™ÂÆå‰∫ÜÈÄöÁü•
                if session_id:
                    category_successful = sum(1 for img in category_images if img.get("generation_success"))
                    await send_progress(
                        session_id, 5, "active", 
                        f"‚úÖ {category}„ÅÆÁîªÂÉèÁîüÊàêÂÆå‰∫ÜÔºÅ{category_successful}/{len(category_images)}Êûö„ÅÆÁîªÂÉè„ÇíÁîüÊàê„Åó„Åæ„Åó„Åü",
                        {
                            "category_completed": category,
                            "category_images": category_images,
                            "successful_images": category_successful,
                            "total_category_items": len(category_images)
                        }
                    )
                
                print(f"‚úÖ Category '{category}' completed: {len(category_images)} items processed, {category_successful} successful")
            
            print(f"üéâ Imagen 3 Image Generation Complete: Generated {successful_images}/{total_items} images")
            
            # Âá¶ÁêÜÁµ±Ë®à„ÇíÁîüÊàê
            statistics = self.extract_generation_statistics(final_menu, images_generated)
            
            return ImageResult(
                success=True,
                images_generated=images_generated,
                total_images=successful_images,
                total_items=total_items,
                image_method="imagen3",
                metadata={
                    "provider": "Imagen 3 (Google)",
                    "model": settings.IMAGEN_MODEL,
                    "successful_images": successful_images,
                    "failed_images": total_items - successful_images,
                    "processing_statistics": statistics,
                    "features": [
                        "professional_food_photography",
                        "category_specific_styling",
                        "japanese_cuisine_focus",
                        "high_quality_generation",
                        "real_time_progress"
                    ],
                    "image_settings": {
                        "model": settings.IMAGEN_MODEL,
                        "aspect_ratio": settings.IMAGEN_ASPECT_RATIO,
                        "number_of_images": settings.IMAGEN_NUMBER_OF_IMAGES,
                        "rate_limit_sleep": settings.IMAGE_RATE_LIMIT_SLEEP
                    }
                }
            )
            
        except Exception as e:
            print(f"‚ùå Imagen 3 Image Generation Failed: {e}")
            
            # „Ç®„É©„Éº„Çø„Ç§„Éó„ÅÆÂà§ÂÆö
            error_type = "unknown_error"
            suggestions = []
            
            if "rate limit" in str(e).lower():
                error_type = "rate_limit_exceeded"
                suggestions = [
                    "Wait before retrying image generation",
                    "Check Gemini API usage limits",
                    "Consider reducing the number of images",
                    "Increase IMAGE_RATE_LIMIT_SLEEP setting"
                ]
            elif "quota" in str(e).lower():
                error_type = "quota_exceeded"
                suggestions = [
                    "Check Gemini API quota limits",
                    "Upgrade your Gemini API plan",
                    "Try generating fewer images",
                    "Contact Google Cloud support"
                ]
            elif "authentication" in str(e).lower() or "api key" in str(e).lower():
                error_type = "authentication_error"
                suggestions = [
                    "Check GEMINI_API_KEY is valid",
                    "Verify API key permissions",
                    "Ensure Imagen 3 access is enabled",
                    "Check Google Cloud project settings"
                ]
            else:
                suggestions = [
                    "Check GEMINI_API_KEY is valid",
                    "Verify Imagen 3 service availability",
                    "Check internet connectivity",
                    "Ensure menu data is properly formatted"
                ]
            
            return ImageResult(
                success=False,
                image_method="imagen3",
                error=f"Imagen 3 image generation error: {str(e)}",
                metadata={
                    "error_type": error_type,
                    "original_error": str(e),
                    "suggestions": suggestions,
                    "provider": "Imagen 3 (Google)",
                    "model": settings.IMAGEN_MODEL,
                    "processed_items": processed_items if 'processed_items' in locals() else 0,
                    "total_items": sum(len(items) for items in final_menu.values())
                }
            )
    
    def get_service_info(self) -> dict:
        """Imagen 3„Çµ„Éº„Éì„ÇπÂõ∫Êúâ„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó"""
        base_info = super().get_service_info()
        
        imagen3_specific = {
            "model": settings.IMAGEN_MODEL,
            "provider_name": "Google Imagen 3",
            "aspect_ratio": settings.IMAGEN_ASPECT_RATIO,
            "images_per_request": settings.IMAGEN_NUMBER_OF_IMAGES,
            "rate_limit_sleep": settings.IMAGE_RATE_LIMIT_SLEEP,
            "image_format": "PNG",
            "max_resolution": "High quality restaurant photography",
            "specializations": [
                "professional_food_photography",
                "japanese_cuisine_styling",
                "menu_item_presentation",
                "category_specific_aesthetics"
            ]
        }
        
        # „Éô„Éº„ÇπÊÉÖÂ†±„Å´Imagen 3Âõ∫ÊúâÊÉÖÂ†±„ÇíËøΩÂä†
        base_info.update(imagen3_specific)
        return base_info
    
    def get_supported_styles(self) -> dict:
        """„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Çã„Çπ„Çø„Ç§„É´‰∏ÄË¶ß„ÇíÂèñÂæó"""
        return {
            "food_photography_styles": [
                "professional lighting",
                "appetizing appearance", 
                "clean background",
                "elegant table setting",
                "high quality photography"
            ],
            "category_specific_styles": self.get_category_styles(),
            "japanese_cuisine_focus": [
                "traditional presentation",
                "authentic plating",
                "cultural context",
                "seasonal aesthetics"
            ],
            "technical_specifications": {
                "aspect_ratio": settings.IMAGEN_ASPECT_RATIO,
                "quality": "high",
                "format": "PNG",
                "lighting": "professional"
            }
        }
