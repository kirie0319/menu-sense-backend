import asyncio
import os
from typing import Optional
from datetime import datetime
from io import BytesIO

try:
    from google import genai as imagen_genai
    from google.genai import types
    from PIL import Image
except ImportError:
    imagen_genai = None
    types = None
    Image = None

from app.core.config import settings
from .base import BaseImageService, ImageResult, ImageProvider

class Imagen3Service(BaseImageService):
    """Imagen 3 APIã‚’ä½¿ç”¨ã—ãŸç”»åƒç”Ÿæˆã‚µãƒ¼ãƒ“ã‚¹"""
    
    def __init__(self):
        super().__init__()
        self.provider = ImageProvider.IMAGEN3
        self.client = None
        self._initialize_client()
        # ç”»åƒç”Ÿæˆä¸¦åˆ—å‡¦ç†ç”¨ã‚»ãƒãƒ•ã‚©ï¼ˆåŒæ™‚å®Ÿè¡Œæ•°ã‚’åˆ¶é™ï¼‰
        self.semaphore = asyncio.Semaphore(settings.IMAGE_CONCURRENT_CHUNK_LIMIT)
    
    def _initialize_client(self):
        """Imagen 3 APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’åˆæœŸåŒ–"""
        try:
            if not imagen_genai or not types or not Image:
                print("âŒ google-genai or PIL package not installed. Install with: pip install google-genai pillow")
                return
                
            if settings.GEMINI_API_KEY and settings.IMAGE_GENERATION_ENABLED:
                self.client = imagen_genai.Client(api_key=settings.GEMINI_API_KEY)
                print("ğŸ”§ Imagen 3 Service initialized successfully")
            else:
                print("âš ï¸ GEMINI_API_KEY not set or IMAGE_GENERATION_ENABLED is False")
                
        except Exception as e:
            print(f"âŒ Failed to initialize Imagen 3 Service: {e}")
            self.client = None
    
    def is_available(self) -> bool:
        """ã‚µãƒ¼ãƒ“ã‚¹ãŒåˆ©ç”¨å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯"""
        return (self.client is not None and 
                bool(settings.GEMINI_API_KEY) and 
                settings.IMAGE_GENERATION_ENABLED and
                imagen_genai is not None and
                types is not None and
                Image is not None)
    
    async def generate_single_image(
        self, 
        japanese_name: str, 
        english_name: str, 
        description: str, 
        category: str
    ) -> dict:
        """å˜ä¸€ã®ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚¢ã‚¤ãƒ†ãƒ ã®ç”»åƒã‚’ç”Ÿæˆ"""
        try:
            # ç”»åƒç”Ÿæˆç”¨ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆä½œæˆ
            prompt = self.create_image_prompt(japanese_name, english_name, description, category)
            
            if not self.validate_prompt_content(prompt):
                raise ValueError("Invalid prompt content")
            
            # Imagen 3ã§ç”»åƒç”Ÿæˆ
            response = self.client.models.generate_images(
                model=settings.IMAGEN_MODEL,
                prompt=prompt,
                config=types.GenerateImagesConfig(
                    number_of_images=settings.IMAGEN_NUMBER_OF_IMAGES,
                    aspect_ratio=settings.IMAGEN_ASPECT_RATIO
                )
            )
            
            if response.generated_images:
                # ç”»åƒã‚’ä¿å­˜
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = self.create_safe_filename(english_name, timestamp)
                image_path = f"{settings.UPLOAD_DIR}/{filename}"
                
                # ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆ
                os.makedirs(settings.UPLOAD_DIR, exist_ok=True)
                
                # ç”»åƒã‚’ä¿å­˜
                generated_image = response.generated_images[0]
                image = Image.open(BytesIO(generated_image.image.image_bytes))
                image.save(image_path)
                
                # çµæœã‚’è¿”ã™
                return {
                    "japanese_name": japanese_name,
                    "english_name": english_name,
                    "image_url": f"/{settings.UPLOAD_DIR}/{filename}",
                    "image_path": image_path,
                    "prompt_used": prompt,
                    "generation_success": True
                }
            else:
                return {
                    "japanese_name": japanese_name,
                    "english_name": english_name,
                    "image_url": None,
                    "error": "No image generated by Imagen 3",
                    "generation_success": False
                }
                
        except Exception as e:
            return {
                "japanese_name": japanese_name,
                "english_name": english_name,
                "image_url": None,
                "error": str(e),
                "generation_success": False
            }
    
    async def process_image_chunk(
        self, 
        category: str, 
        chunk: list, 
        chunk_number: int, 
        total_chunks: int,
        session_id: Optional[str] = None
    ) -> list:
        """ç”»åƒç”Ÿæˆãƒãƒ£ãƒ³ã‚¯ã‚’å‡¦ç†"""
        print(f"  ğŸ–¼ï¸ Processing image chunk {chunk_number}/{total_chunks} ({len(chunk)} items)")
        
        # é€²è¡ŒçŠ¶æ³é€šçŸ¥ï¼ˆãƒãƒ£ãƒ³ã‚¯å‡¦ç†ä¸­ï¼‰
        if session_id:
            from app.main import send_progress
            await send_progress(
                session_id, 5, "active", 
                f"ğŸ¨ Processing {category} images (chunk {chunk_number}/{total_chunks})",
                {"chunk_progress": f"{chunk_number}/{total_chunks}", "parallel_processing": True}
            )
        
        chunk_results = []
        
        try:
            for i, item in enumerate(chunk):
                if not self.validate_menu_item(item):
                    print(f"    âš ï¸ Skipping invalid menu item: {item}")
                    continue
                
                japanese_name = item.get("japanese_name", "N/A")
                english_name = item.get("english_name", "N/A")
                description = item.get("description", "")
                
                print(f"    ğŸ¨ Generating image for: {english_name} (item {i+1}/{len(chunk)})")
                
                # å˜ä¸€ç”»åƒç”Ÿæˆ
                image_result = await self.generate_single_image(
                    japanese_name, english_name, description, category
                )
                
                chunk_results.append(image_result)
                
                if image_result.get("generation_success"):
                    print(f"      âœ… Image generated successfully: {image_result.get('image_url')}")
                else:
                    print(f"      âŒ Failed to generate image: {image_result.get('error', 'Unknown error')}")
                
                # ãƒ¬ãƒ¼ãƒˆåˆ¶é™å¯¾ç­–ï¼ˆãƒãƒ£ãƒ³ã‚¯å†…ã§ã¯çŸ­ã‚ã«ï¼‰
                if i < len(chunk) - 1:  # æœ€å¾Œã®ã‚¢ã‚¤ãƒ†ãƒ ã§ãªã„å ´åˆã®ã¿å¾…æ©Ÿ
                    await asyncio.sleep(settings.IMAGE_RATE_LIMIT_SLEEP * 0.5)
            
            print(f"    âœ… Successfully processed image chunk {chunk_number}/{total_chunks}")
            return chunk_results
            
        except Exception as chunk_error:
            print(f"  âš ï¸ Image chunk processing error: {chunk_error}")
            print(f"    ğŸ”„ Creating fallback results for chunk {chunk_number}")
            
            # ã‚¨ãƒ©ãƒ¼æ™‚ã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯çµæœã‚’ç”Ÿæˆ
            fallback_results = []
            for item in chunk:
                fallback_results.append({
                    "japanese_name": item.get("japanese_name", "N/A"),
                    "english_name": item.get("english_name", "N/A"),
                    "image_url": None,
                    "error": f"Chunk processing error: {str(chunk_error)}",
                    "generation_success": False
                })
            
            return fallback_results
    
    async def process_image_chunk_with_semaphore(
        self, 
        category: str, 
        chunk: list, 
        chunk_number: int, 
        total_chunks: int,
        session_id: Optional[str] = None
    ) -> tuple:
        """ã‚»ãƒãƒ•ã‚©ã‚’ä½¿ç”¨ã—ã¦ç”»åƒãƒãƒ£ãƒ³ã‚¯ã‚’ä¸¦åˆ—å‡¦ç†"""
        async with self.semaphore:
            print(f"  ğŸš€ Starting parallel image chunk {chunk_number}/{total_chunks} ({len(chunk)} items)")
            
            # é€²è¡ŒçŠ¶æ³é€šçŸ¥ï¼ˆãƒãƒ£ãƒ³ã‚¯é–‹å§‹ï¼‰
            if session_id:
                from app.main import send_progress
                await send_progress(
                    session_id, 5, "active", 
                    f"ğŸš€ Starting parallel image generation for {category} (chunk {chunk_number}/{total_chunks})",
                    {
                        "chunk_progress": f"{chunk_number}/{total_chunks}",
                        "parallel_processing": True,
                        "chunk_started": chunk_number
                    }
                )
            
            try:
                # ãƒãƒ£ãƒ³ã‚¯å‡¦ç†ã‚’å®Ÿè¡Œ
                result = await self.process_image_chunk(category, chunk, chunk_number, total_chunks, session_id)
                
                print(f"  âœ… Completed parallel image chunk {chunk_number}/{total_chunks}")
                return (chunk_number, result, None)  # (chunk_number, result, error)
                
            except Exception as e:
                print(f"  âŒ Error in parallel image chunk {chunk_number}/{total_chunks}: {e}")
                return (chunk_number, None, str(e))
    
    async def process_category_parallel(
        self,
        category: str,
        items: list,
        session_id: Optional[str] = None
    ) -> list:
        """ã‚«ãƒ†ã‚´ãƒªå†…ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’ä¸¦åˆ—ãƒãƒ£ãƒ³ã‚¯å‡¦ç†ã§ç”»åƒç”Ÿæˆ"""
        if not items:
            return []
            
        print(f"ğŸ¨ Processing category images: {category} ({len(items)} items) - PARALLEL MODE")
        
        # é€²è¡ŒçŠ¶æ³é€šçŸ¥ï¼ˆã‚«ãƒ†ã‚´ãƒªé–‹å§‹ï¼‰
        if session_id:
            from app.main import send_progress
            await send_progress(
                session_id, 5, "active", 
                f"ğŸ¨ Generating images for {category} (parallel processing)...",
                {
                    "processing_category": category,
                    "parallel_mode": True,
                    "total_items": len(items)
                }
            )
        
        # ãƒãƒ£ãƒ³ã‚¯ã«åˆ†å‰²
        chunk_size = settings.IMAGE_PROCESSING_CHUNK_SIZE
        chunks = []
        
        for i in range(0, len(items), chunk_size):
            chunk = items[i:i + chunk_size]
            chunk_number = (i // chunk_size) + 1
            total_chunks = (len(items) + chunk_size - 1) // chunk_size
            chunks.append((chunk, chunk_number, total_chunks))
        
        print(f"  ğŸ“¦ Created {len(chunks)} image chunks for parallel processing")
        
        # å…¨ãƒãƒ£ãƒ³ã‚¯ã‚’ä¸¦åˆ—ã§å‡¦ç†
        tasks = []
        for chunk, chunk_number, total_chunks in chunks:
            task = self.process_image_chunk_with_semaphore(
                category, chunk, chunk_number, total_chunks, session_id
            )
            tasks.append(task)
        
        # ä¸¦åˆ—å®Ÿè¡Œé–‹å§‹
        print(f"  ğŸš€ Starting {len(tasks)} parallel image chunk tasks...")
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # çµæœã‚’å‡¦ç†
        category_results = []
        successful_chunks = 0
        failed_chunks = 0
        
        # ãƒãƒ£ãƒ³ã‚¯ç•ªå·ã§ã‚½ãƒ¼ãƒˆï¼ˆå…ƒã®é †åºã‚’ç¶­æŒï¼‰
        sorted_results = []
        for result in results:
            if isinstance(result, tuple):
                sorted_results.append(result)
            else:
                # ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸå ´åˆ
                print(f"  âš ï¸ Exception in parallel image processing: {result}")
                failed_chunks += 1
        
        sorted_results.sort(key=lambda x: x[0])  # chunk_numberã§ã‚½ãƒ¼ãƒˆ
        
        for chunk_number, chunk_result, error in sorted_results:
            if error:
                print(f"  âš ï¸ Image chunk {chunk_number} failed: {error}")
                failed_chunks += 1
                # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†ï¼ˆç©ºã®çµæœã‚’è¿½åŠ ï¼‰
            elif chunk_result:
                category_results.extend(chunk_result)
                successful_chunks += 1
                
                # ãƒãƒ£ãƒ³ã‚¯å®Œäº†ã®é€²æ—é€ä¿¡
                if session_id:
                    successful_images = sum(1 for img in chunk_result if img.get("generation_success"))
                    await send_progress(
                        session_id, 5, "active", 
                        f"ğŸ¨ {category}: Image chunk {chunk_number} completed ({successful_images}/{len(chunk_result)} images)",
                        {
                            "processing_category": category,
                            "chunk_completed": chunk_number,
                            "chunk_result": chunk_result,
                            "parallel_processing": True,
                            "successful_chunks": successful_chunks,
                            "failed_chunks": failed_chunks,
                            "chunk_images_generated": successful_images,
                            "chunk_images_failed": len(chunk_result) - successful_images
                        }
                    )
        
        print(f"  âœ… Parallel image processing complete: {successful_chunks} successful, {failed_chunks} failed chunks")
        
        # ã‚«ãƒ†ã‚´ãƒªå®Œäº†é€šçŸ¥
        if session_id:
            category_successful = sum(1 for img in category_results if img.get("generation_success"))
            await send_progress(
                session_id, 5, "active", 
                f"âœ… {category}ã®ç”»åƒç”Ÿæˆå®Œäº†ï¼{category_successful}/{len(category_results)}æšã®ç”»åƒã‚’ä¸¦åˆ—å‡¦ç†ã§ç”Ÿæˆã—ã¾ã—ãŸ",
                {
                    "category_completed": category,
                    "category_images": category_results,
                    "successful_images": category_successful,
                    "total_category_items": len(category_results),
                    "parallel_processing_stats": {
                        "successful_chunks": successful_chunks,
                        "failed_chunks": failed_chunks,
                        "total_chunks": len(chunks),
                        "processing_mode": "parallel"
                    }
                }
            )
        
        return category_results
    
    async def generate_images(
        self, 
        final_menu: dict, 
        session_id: Optional[str] = None
    ) -> ImageResult:
        """
        ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚¢ã‚¤ãƒ†ãƒ ã®ç”»åƒã‚’Imagen 3ã§ç”Ÿæˆ
        
        Args:
            final_menu: è©³ç´°èª¬æ˜ä»˜ããƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒ‡ãƒ¼ã‚¿
            session_id: ã‚»ãƒƒã‚·ãƒ§ãƒ³IDï¼ˆé€²è¡ŒçŠ¶æ³é€šçŸ¥ç”¨ï¼‰
            
        Returns:
            ImageResult: ç”»åƒç”Ÿæˆçµæœ
        """
        print("ğŸ¨ Starting image generation with Imagen 3...")
        
        # ã‚µãƒ¼ãƒ“ã‚¹åˆ©ç”¨å¯èƒ½æ€§ãƒã‚§ãƒƒã‚¯
        if not self.is_available():
            return ImageResult(
                success=True,  # ç”»åƒç”Ÿæˆã¯ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ãªã®ã§æˆåŠŸã¨ã™ã‚‹
                image_method="imagen3",
                metadata={
                    "skipped_reason": "Imagen 3 not available",
                    "error_type": "service_unavailable",
                    "suggestions": [
                        "Set GEMINI_API_KEY environment variable",
                        "Install required packages: google-genai, pillow",
                        "Enable IMAGE_GENERATION_ENABLED in settings",
                        "Check Gemini API access permissions"
                    ]
                }
            )
        
        # å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
        if not self.validate_menu_data(final_menu):
            return ImageResult(
                success=False,
                image_method="imagen3",
                error="Invalid menu data",
                metadata={
                    "error_type": "invalid_input",
                    "suggestions": [
                        "Provide valid menu data with descriptions",
                        "Ensure at least one category has menu items",
                        "Check menu data structure format"
                    ]
                }
            )
        
        try:
            images_generated = {}
            total_items = sum(len(items) for items in final_menu.values())
            processed_items = 0
            successful_images = 0
            
            print(f"ğŸ–¼ï¸ Total items to generate images for: {total_items}")
            print(f"ğŸš€ Parallel image processing enabled with max {settings.IMAGE_CONCURRENT_CHUNK_LIMIT} concurrent chunks")
            
            # ã‚«ãƒ†ã‚´ãƒªã®ä¸¦åˆ—å‡¦ç†ã‚‚å¯èƒ½ã«ã™ã‚‹ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
            if settings.ENABLE_IMAGE_CATEGORY_PARALLEL and len(final_menu) > 1:
                print("ğŸŒŸ Category-level parallel image processing enabled")
                
                # ã‚«ãƒ†ã‚´ãƒªã”ã¨ã®å‡¦ç†ã‚¿ã‚¹ã‚¯ã‚’ä½œæˆ
                category_tasks = []
                for category, items in final_menu.items():
                    if items:  # ç©ºã§ãªã„ã‚«ãƒ†ã‚´ãƒªã®ã¿å‡¦ç†
                        task = self.process_category_parallel(category, items, session_id)
                        category_tasks.append((category, task))
                
                # ã‚«ãƒ†ã‚´ãƒªã‚’ä¸¦åˆ—ã§å‡¦ç†
                category_results = await asyncio.gather(
                    *[task for _, task in category_tasks], 
                    return_exceptions=True
                )
                
                # çµæœã‚’ãƒãƒƒãƒ”ãƒ³ã‚°
                for i, (category, _) in enumerate(category_tasks):
                    if i < len(category_results) and not isinstance(category_results[i], Exception):
                        images_generated[category] = category_results[i]
                        # æˆåŠŸã—ãŸç”»åƒæ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
                        successful_images += sum(1 for img in category_results[i] if img.get("generation_success"))
                    else:
                        print(f"âš ï¸ Category {category} image processing failed")
                        images_generated[category] = []
                
                # ç©ºã®ã‚«ãƒ†ã‚´ãƒªã‚’è¿½åŠ 
                for category, items in final_menu.items():
                    if not items:
                        images_generated[category] = []
                        
            else:
                # ã‚«ãƒ†ã‚´ãƒªã”ã¨ã«é †æ¬¡å‡¦ç†ï¼ˆä½†ã—ãƒãƒ£ãƒ³ã‚¯å†…ã¯ä¸¦åˆ—ï¼‰
                for category, items in final_menu.items():
                    if not items:
                        images_generated[category] = []
                        continue
                    
                    # ã‚«ãƒ†ã‚´ãƒªå†…ä¸¦åˆ—å‡¦ç†ã‚’å®Ÿè¡Œ
                    category_results = await self.process_category_parallel(category, items, session_id)
                    images_generated[category] = category_results
                    
                    # æˆåŠŸã—ãŸç”»åƒæ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
                    successful_images += sum(1 for img in category_results if img.get("generation_success"))
            
            print(f"ğŸ‰ Imagen 3 Image Generation Complete: Generated {successful_images}/{total_items} images")
            
            # å‡¦ç†çµ±è¨ˆã‚’ç”Ÿæˆ
            statistics = self.extract_generation_statistics(final_menu, images_generated)
            
            return ImageResult(
                success=True,
                images_generated=images_generated,
                total_images=successful_images,
                total_items=total_items,
                image_method="imagen3",
                metadata={
                    "provider": "Imagen 3 (Google)",
                    "model": settings.IMAGEN_MODEL,
                    "successful_images": successful_images,
                    "failed_images": total_items - successful_images,
                    "processing_statistics": statistics,
                    "features": [
                        "professional_food_photography",
                        "category_specific_styling",
                        "japanese_cuisine_focus",
                        "high_quality_generation",
                        "real_time_progress",
                        "parallel_chunked_processing"
                    ],
                    "image_settings": {
                        "model": settings.IMAGEN_MODEL,
                        "aspect_ratio": settings.IMAGEN_ASPECT_RATIO,
                        "number_of_images": settings.IMAGEN_NUMBER_OF_IMAGES,
                        "rate_limit_sleep": settings.IMAGE_RATE_LIMIT_SLEEP
                    },
                    "parallel_processing": {
                        "enabled": True,
                        "concurrent_chunk_limit": settings.IMAGE_CONCURRENT_CHUNK_LIMIT,
                        "category_parallel": settings.ENABLE_IMAGE_CATEGORY_PARALLEL,
                        "chunk_size": settings.IMAGE_PROCESSING_CHUNK_SIZE,
                        "processing_mode": "parallel_chunked"
                    }
                }
            )
            
        except Exception as e:
            print(f"âŒ Imagen 3 Image Generation Failed: {e}")
            
            # ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ã®åˆ¤å®š
            error_type = "unknown_error"
            suggestions = []
            
            if "rate limit" in str(e).lower():
                error_type = "rate_limit_exceeded"
                suggestions = [
                    "Wait before retrying image generation",
                    "Check Gemini API usage limits",
                    "Consider reducing the number of images",
                    "Increase IMAGE_RATE_LIMIT_SLEEP setting"
                ]
            elif "quota" in str(e).lower():
                error_type = "quota_exceeded"
                suggestions = [
                    "Check Gemini API quota limits",
                    "Upgrade your Gemini API plan",
                    "Try generating fewer images",
                    "Contact Google Cloud support"
                ]
            elif "authentication" in str(e).lower() or "api key" in str(e).lower():
                error_type = "authentication_error"
                suggestions = [
                    "Check GEMINI_API_KEY is valid",
                    "Verify API key permissions",
                    "Ensure Imagen 3 access is enabled",
                    "Check Google Cloud project settings"
                ]
            else:
                suggestions = [
                    "Check GEMINI_API_KEY is valid",
                    "Verify Imagen 3 service availability",
                    "Check internet connectivity",
                    "Ensure menu data is properly formatted"
                ]
            
            return ImageResult(
                success=False,
                image_method="imagen3",
                error=f"Imagen 3 image generation error: {str(e)}",
                metadata={
                    "error_type": error_type,
                    "original_error": str(e),
                    "suggestions": suggestions,
                    "provider": "Imagen 3 (Google)",
                    "model": settings.IMAGEN_MODEL,
                    "processed_items": processed_items if 'processed_items' in locals() else 0,
                    "total_items": sum(len(items) for items in final_menu.values())
                }
            )
    
    def get_service_info(self) -> dict:
        """Imagen 3ã‚µãƒ¼ãƒ“ã‚¹å›ºæœ‰ã®æƒ…å ±ã‚’å–å¾—"""
        base_info = super().get_service_info()
        
        imagen3_specific = {
            "model": settings.IMAGEN_MODEL,
            "provider_name": "Google Imagen 3",
            "aspect_ratio": settings.IMAGEN_ASPECT_RATIO,
            "images_per_request": settings.IMAGEN_NUMBER_OF_IMAGES,
            "rate_limit_sleep": settings.IMAGE_RATE_LIMIT_SLEEP,
            "image_format": "PNG",
            "max_resolution": "High quality restaurant photography",
            "specializations": [
                "professional_food_photography",
                "japanese_cuisine_styling",
                "menu_item_presentation",
                "category_specific_aesthetics"
            ]
        }
        
        # ãƒ™ãƒ¼ã‚¹æƒ…å ±ã«Imagen 3å›ºæœ‰æƒ…å ±ã‚’è¿½åŠ 
        base_info.update(imagen3_specific)
        return base_info
    
    def get_supported_styles(self) -> dict:
        """ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã‚¹ã‚¿ã‚¤ãƒ«ä¸€è¦§ã‚’å–å¾—"""
        return {
            "food_photography_styles": [
                "professional lighting",
                "appetizing appearance", 
                "clean background",
                "elegant table setting",
                "high quality photography"
            ],
            "category_specific_styles": self.get_category_styles(),
            "japanese_cuisine_focus": [
                "traditional presentation",
                "authentic plating",
                "cultural context",
                "seasonal aesthetics"
            ],
            "technical_specifications": {
                "aspect_ratio": settings.IMAGEN_ASPECT_RATIO,
                "quality": "high",
                "format": "PNG",
                "lighting": "professional"
            }
        }
